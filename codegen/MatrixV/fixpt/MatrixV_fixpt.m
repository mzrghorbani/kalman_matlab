%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                          %
%           Generated by MATLAB 9.5 and Fixed-Point Designer 6.2           %
%                                                                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#codegen
function [V] = MatrixV_fixpt(r, z, inv2R, tanL)
    fm = get_fimath();

    V = fi(zeros(4,1), 0, 16, 4, fm);
    V(2,1) = 0;
    V(3,1) = 0;
    bField = fi(3.8112, 0, 16, 14, fm);
    rMult = fi(9.938, 0, 16, 12, fm);
    phiMult = fi(20860.75, 0, 16, 1, fm);
    rphiMult = fi(rMult * phiMult, 0, 16, -2, fm);
    invRoot12  = fi(0.288675, 0, 16, 17, fm);
    pitchPS = fi(rphiMult * invRoot12 * fi(0.0099, 0, 16, 22, fm), 0, 16, 6, fm);
    pitch2S = fi(rphiMult * invRoot12 * fi(0.0089, 0, 16, 22, fm), 0, 16, 6, fm);
    lengthPS = fi(fi(1.41, 0, 16, 15, fm)*rMult * invRoot12 * fi(0.15, 0, 16, 18, fm), 0, 16, 16, fm);
    length2S = fi(rMult * invRoot12 * fi(5.02, 0, 16, 13, fm), 0, 16, 12, fm); 
    lengthPS105 = fi(fi(1.05, 0, 16, 15, fm) * lengthPS, 0, 16, 16, fm);
    length2S105 = fi(fi(1.05, 0, 16, 15, fm) * length2S, 0, 16, 12, fm);
    lengthPS09  = fi(fi(0.9, 0, 16, 16, fm) * lengthPS, 0, 16, 16, fm);
    length2S09  = fi(fi(0.9, 0, 16, 16, fm) * length2S, 0, 16, 12, fm);
    zBarrel = fi(rMult * fi(125, 0, 7, 0, fm), 0, 16, 5, fm);
    zWheel12 = fi(rMult * fi(170, 0, 8, 0, fm), 0, 16, 5, fm);
    rPSbarrel = fi(rMult * fi(60.0, 0, 6, 0, fm), 0, 16, 6, fm);
    rPSwheel12 = fi(rMult * fi(66.4, 0, 16, 9, fm), 0, 16, 6, fm);
    rPSwheel345 = fi(rMult * fi(64.6, 0, 16, 9, fm), 0, 16, 6, fm);
    
    pitchPSoverR_2 = fi(PitchOverR_2_s1(pitchPS, r), 0, 1, 0, fm);
    pitch2SoverR_2 = fi(PitchOverR_2_s2(pitch2S, r), 0, 1, 0, fm);
    
    absZ = fi(z, 1, 13, 0, fm);

    if (z(1) < fi(0, 0, 1, 0, fm))
        absZ(:) = fi_uminus(z);
    end
    
    calcPhiExtra2_PS = fi(InvPt2(fi(1, 0, 1, 0, fm), lengthPS), 0, 16, 15, fm);
    calcPhiExtra2_2S = fi(InvPt2(fi(1, 0, 1, 0, fm), length2S), 0, 16, 5, fm);
    
    if (absZ(1) < zBarrel)
        if (r(1) < rPSbarrel)
            sigmaPhi2 = fi(pitchPSoverR_2, 0, 1, 0, fm);
            sigmaZ   = fi(lengthPS, 1, 16, 9, fm);
        else
            %F2F: No information found for converting the following block of code
            %F2F: Start block
            sigmaPhi2 = fi(pitch2SoverR_2, 0, 1, 0, fm);
            sigmaZ   = fi(length2S, 1, 16, 9, fm);
            %F2F: End block
        end
            sigmaPhiExtra2 = fi(0, 0, 16, 7, fm);
    else

        if(absZ < zWheel12)
            psEndcap = r < rPSwheel12;
        else
            psEndcap = r < rPSwheel345;
        end

        if (psEndcap == 1)
            sigmaPhi2 = fi(pitchPSoverR_2, 0, 1, 0, fm);
            sigmaZ = fi(lengthPS*tanL, 1, 16, 9, fm);
            sigmaPhiExtra2 = fi(392.0605, 0, 16, 7, fm);
        else
            sigmaPhi2 = fi(pitch2SoverR_2, 0, 1, 0, fm);
            sigmaZ = fi(length2S*tanL, 1, 16, 9, fm);
            sigmaPhiExtra2 = fi(392.0605, 0, 16, 7, fm);
        end
    end
   
    V(1,1) = sigmaPhi2 + sigmaPhiExtra2 + fi(3.2129, 0, 16, 14, fm);
    V(4,1) = sigmaZ * sigmaZ;
end

function [ y ] = PitchOverR_2_s1(pitch, r)
    fm = get_fimath();

    get = fi(zeros(512,1), 0, 16, 23, fm);
    for n = 3:511
      pitchOverR = fi(fi_div(pitch, (bitshift(n,4) + fi(0.5, 0, 16, 16, fm) * bitshift(1,4))), 0, 16, 12, fm);
    end 
    get(n) = pitchOverR * pitchOverR;
    y = fi(get(round(fi_div_by_shift(r, 2))), 0, 1, 0, fm);
end

function [ y ] = PitchOverR_2_s2(pitch, r)
    fm = get_fimath();

    get = fi(zeros(512,1), 0, 16, 23, fm);
    for n = 3:511
      pitchOverR = fi(fi_div(pitch, (bitshift(n,4) + fi(0.5, 0, 16, 16, fm) * bitshift(1,4))), 0, 16, 12, fm);
    end 
    get(n) = pitchOverR * pitchOverR;
    y = fi(get(round(fi_div_by_shift(r, 2))), 0, 1, 0, fm);
end

function [ y ] = InvPt2(iOpt, scaleFactor)
    fm = get_fimath();

    rMult = fi(2^12 / 103.0382, 0, 16, 10, fm);
    phiMult = fi(2^14 / 0.698131701, 0, 16, 1, fm);
    inv2R_Mult = fi(fi_div(phiMult, rMult), 0, 16, 6, fm);
    bField = fi(3.8112, 0, 16, 14, fm);
    invPtToInvR = fi(bField * (fi(3.0e8 / 1.0e11, 0, 16, 24, fm)), 0, 16, 22, fm);
    minPtBin = fi(-18, 1, 6, 0, fm);
    maxPtBin = fi(17, 0, 5, 0, fm);
    minPt_HT = fi(3, 0, 2, 0, fm);
    numPtBins = fi(36, 0, 6, 0, fm);
    if(iOpt == fi(0, 0, 1, 0, fm))
        %F2F: No information found for converting the following block of code
        %F2F: Start block
        theConst = kalmanMultScatTerm * phiMult;
        %F2F: End block
    else
       theConst = fi((fi(0.5, 0, 16, 16, fm) * invPtToInvR * scaleFactor * inv2R_Mult), 0, 16, 10, fm);
    end
    
    get = fi(zeros(36,1), 0, 16, 5, fm);
    for m = 1 : 1 : 36
       constOverPt = fi(fi_div(theConst * (fi_div(fi(1, 0, 1, 0, fm), minPt_HT)) * fi((m + 0.5), 0, 16, 10, fm), (fi_div_by_shift(numPtBins, 1))), 0, 16, 10, fm);
       get(m) = constOverPt * constOverPt;
       y = fi(get, 0, 16, 5, fm);
    end
end



function ntype = divideType(a,b)
    coder.inline( 'always' );
    nt1 = numerictype( a );
    nt2 = numerictype( b );
    maxFL = max( [ min( nt1.WordLength, nt1.FractionLength ), min( nt2.WordLength, nt2.FractionLength ) ] );
    FL = max( maxFL, 24 );
    extraBits = (FL - maxFL);
    WL = nt1.WordLength + nt2.WordLength;
    WL = min( WL, 124 );
    if (WL + extraBits)<64
        ntype = numerictype( nt1.Signed || nt2.Signed, WL + extraBits, FL );
    else
        ntype = numerictype( nt1.Signed || nt2.Signed, WL, FL );
    end
end


function c = fi_div(a,b)
    coder.inline( 'always' );
    if isfi( a ) && isfi( b ) && isscalar( b )
        a1 = fi( a, 'RoundMode', 'fix' );
        b1 = fi( b, 'RoundMode', 'fix' );
        c1 = divide( divideType( a1, b1 ), a1, b1 );
        c = fi( c1, numerictype( c1 ), fimath( a ) );
    else
        c = a/b;
    end
end


function y = fi_div_by_shift(a,shift_len)
    coder.inline( 'always' );
    if isfi( a )
        nt = numerictype( a );
        fm = fimath( a );
        nt_bs = numerictype( nt.Signed, nt.WordLength + shift_len, nt.FractionLength + shift_len );
        y = bitsra( fi( a, nt_bs, fm ), shift_len );
    else
        y = a/2^shift_len;
    end
end


function y = fi_uminus(a)
    coder.inline( 'always' );
    if isfi( a )
        nt = numerictype( a );
        new_nt = numerictype( 1, nt.WordLength + 1, nt.FractionLength );
        y = -fi( a, new_nt, fimath( a ) );
    else
        y = -a;
    end
end

function fm = get_fimath()
	fm = fimath('RoundingMethod', 'Floor',...
	     'OverflowAction', 'Wrap',...
	     'ProductMode','FullPrecision',...
	     'MaxProductWordLength', 128,...
	     'SumMode','FullPrecision',...
	     'MaxSumWordLength', 128);
end
