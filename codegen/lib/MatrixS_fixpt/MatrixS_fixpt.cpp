//
// Prerelease License - for engineering feedback and testing purposes
// only. Not for sale.
// File: MatrixS_fixpt.cpp
//
// MATLAB Coder version            : 4.1
// C/C++ source code generated on  : 06-Jul-2018 18:42:13
//

// Include Files
#include <math.h>
#include "rt_nonfinite.h"
#include "MatrixS_fixpt.h"

// Function Definitions

//
// Arguments    : const short H[8]
//                const short C[16]
//                short S[8]
// Return Type  : void
//
void MatrixS_fixpt(const short H[8], const short C[16], short S[8])
{
  int i;
  int i1;
  double d0;
  double d1;
  double d2;
  int i0;
  double d3;
  double d4;
  int b_i1;
  int i2;
  int i3;
  int i4;
  int i5;
  int i6;
  int i7;
  int i8;
  int i9;

  // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
  //                                                                           % 
  //            Generated by MATLAB 9.5 and Fixed-Point Designer 6.2           % 
  //                                                                           % 
  // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
  for (i = 0; i < 8; i++) {
    S[i] = 0;
  }

  for (i = 0; i < 2; i++) {
    for (i1 = 0; i1 < 4; i1++) {
      d0 = floor((double)((unsigned long)i1 << 1UL));
      if (rtIsNaN(d0) || rtIsInf(d0)) {
        d1 = 0.0;
      } else {
        d1 = fmod(d0, 4.0);
      }

      S[(int)((unsigned int)(1 + i) + ((unsigned char)(signed char)d1 & 3)) - 1]
        = 0;
      if (rtIsNaN(d0) || rtIsInf(d0)) {
        d1 = 0.0;
        d2 = 0.0;
      } else {
        d1 = fmod(d0, 4.0);
        d2 = fmod(d0, 4.0);
      }

      i0 = S[(int)((unsigned int)(1 + i) + ((unsigned char)(signed char)d2 & 3))
        - 1];
      d3 = floor((double)((unsigned long)i1 << 2UL));
      if (rtIsNaN(d3) || rtIsInf(d3)) {
        d4 = 0.0;
      } else {
        d4 = fmod(d3, 8.0);
      }

      b_i1 = H[i] * C[(unsigned char)(signed char)d4 & 7];
      if ((b_i1 & 67108864) != 0) {
        b_i1 |= -67108864;
      } else {
        b_i1 &= 67108863;
      }

      if ((i0 & 134217728) != 0) {
        i2 = i0 | -134217728;
      } else {
        i2 = i0 & 134217727;
      }

      if ((b_i1 & 134217728) != 0) {
        i3 = b_i1 | -134217728;
      } else {
        i3 = b_i1 & 134217727;
      }

      i0 = i2 + i3;
      if ((i0 & 134217728) != 0) {
        S[(int)((unsigned int)(1 + i) + ((unsigned char)(signed char)d1 & 3)) -
          1] = (short)(i0 | -134217728);
      } else {
        S[(int)((unsigned int)(1 + i) + ((unsigned char)(signed char)d1 & 3)) -
          1] = (short)(i0 & 134217727);
      }

      if (rtIsNaN(d0) || rtIsInf(d0)) {
        d1 = 0.0;
        d2 = 0.0;
      } else {
        d1 = fmod(d0, 4.0);
        d2 = fmod(d0, 4.0);
      }

      i0 = S[(int)((unsigned int)(1 + i) + ((unsigned char)(signed char)d2 & 3))
        - 1];
      if (rtIsNaN(d3) || rtIsInf(d3)) {
        d4 = 0.0;
      } else {
        d4 = fmod(d3, 8.0);
      }

      b_i1 = H[i + 2] * C[((unsigned char)(signed char)d4 & 7) + 1];
      if ((b_i1 & 67108864) != 0) {
        b_i1 |= -67108864;
      } else {
        b_i1 &= 67108863;
      }

      if ((i0 & 134217728) != 0) {
        i4 = i0 | -134217728;
      } else {
        i4 = i0 & 134217727;
      }

      if ((b_i1 & 134217728) != 0) {
        i5 = b_i1 | -134217728;
      } else {
        i5 = b_i1 & 134217727;
      }

      i0 = i4 + i5;
      if ((i0 & 134217728) != 0) {
        S[(int)((unsigned int)(1 + i) + ((unsigned char)(signed char)d1 & 3)) -
          1] = (short)(i0 | -134217728);
      } else {
        S[(int)((unsigned int)(1 + i) + ((unsigned char)(signed char)d1 & 3)) -
          1] = (short)(i0 & 134217727);
      }

      if (rtIsNaN(d0) || rtIsInf(d0)) {
        d1 = 0.0;
        d2 = 0.0;
      } else {
        d1 = fmod(d0, 4.0);
        d2 = fmod(d0, 4.0);
      }

      i0 = S[(int)((unsigned int)(1 + i) + ((unsigned char)(signed char)d2 & 3))
        - 1];
      if (rtIsNaN(d3) || rtIsInf(d3)) {
        d4 = 0.0;
      } else {
        d4 = fmod(d3, 8.0);
      }

      b_i1 = H[i] * C[((unsigned char)(signed char)d4 & 7) + 2];
      if ((b_i1 & 67108864) != 0) {
        b_i1 |= -67108864;
      } else {
        b_i1 &= 67108863;
      }

      if ((i0 & 134217728) != 0) {
        i6 = i0 | -134217728;
      } else {
        i6 = i0 & 134217727;
      }

      if ((b_i1 & 134217728) != 0) {
        i7 = b_i1 | -134217728;
      } else {
        i7 = b_i1 & 134217727;
      }

      i0 = i6 + i7;
      if ((i0 & 134217728) != 0) {
        S[(int)((unsigned int)(1 + i) + ((unsigned char)(signed char)d1 & 3)) -
          1] = (short)(i0 | -134217728);
      } else {
        S[(int)((unsigned int)(1 + i) + ((unsigned char)(signed char)d1 & 3)) -
          1] = (short)(i0 & 134217727);
      }

      if (rtIsNaN(d0) || rtIsInf(d0)) {
        d1 = 0.0;
        d0 = 0.0;
      } else {
        d1 = fmod(d0, 4.0);
        d0 = fmod(d0, 4.0);
      }

      i0 = S[(int)((unsigned int)(1 + i) + ((unsigned char)(signed char)d0 & 3))
        - 1];
      if (rtIsNaN(d3) || rtIsInf(d3)) {
        d2 = 0.0;
      } else {
        d2 = fmod(d3, 8.0);
      }

      b_i1 = H[i + 2] * C[((unsigned char)(signed char)d2 & 7) + 3];
      if ((b_i1 & 67108864) != 0) {
        b_i1 |= -67108864;
      } else {
        b_i1 &= 67108863;
      }

      if ((i0 & 134217728) != 0) {
        i8 = i0 | -134217728;
      } else {
        i8 = i0 & 134217727;
      }

      if ((b_i1 & 134217728) != 0) {
        i9 = b_i1 | -134217728;
      } else {
        i9 = b_i1 & 134217727;
      }

      i0 = i8 + i9;
      if ((i0 & 134217728) != 0) {
        S[(int)((unsigned int)(1 + i) + ((unsigned char)(signed char)d1 & 3)) -
          1] = (short)(i0 | -134217728);
      } else {
        S[(int)((unsigned int)(1 + i) + ((unsigned char)(signed char)d1 & 3)) -
          1] = (short)(i0 & 134217727);
      }
    }
  }
}

//
// File trailer for MatrixS_fixpt.cpp
//
// [EOF]
//
