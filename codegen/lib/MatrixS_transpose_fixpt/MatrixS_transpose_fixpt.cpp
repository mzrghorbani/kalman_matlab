//
// Prerelease License - for engineering feedback and testing purposes
// only. Not for sale.
// File: MatrixS_transpose_fixpt.cpp
//
// MATLAB Coder version            : 4.1
// C/C++ source code generated on  : 28-Jun-2018 14:32:10
//

// Include Files
#include <cmath>
#include "rt_nonfinite.h"
#include "MatrixS_transpose_fixpt.h"

// Function Definitions

//
// Arguments    : const short S[8]
//                short St[8]
// Return Type  : void
//
void MatrixS_transpose_fixpt(const short S[8], short St[8])
{
  int i;
  double d0;
  double d1;

  // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
  //                                                                           % 
  //            Generated by MATLAB 9.5 and Fixed-Point Designer 6.2           % 
  //                                                                           % 
  // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
  for (i = 0; i < 8; i++) {
    St[i] = 0;
  }

  for (i = 0; i < 2; i++) {
    d0 = std::floor((double)((unsigned long)i << 2UL));
    if (rtIsNaN(d0) || rtIsInf(d0)) {
      d1 = 0.0;
    } else {
      d1 = std::fmod(d0, 8.0);
    }

    St[(unsigned char)(signed char)d1 & 7] = S[i];
    if (rtIsNaN(d0) || rtIsInf(d0)) {
      d1 = 0.0;
    } else {
      d1 = std::fmod(d0, 8.0);
    }

    St[((unsigned char)(signed char)d1 & 7) + 1] = S[i + 2];
    if (rtIsNaN(d0) || rtIsInf(d0)) {
      d1 = 0.0;
    } else {
      d1 = std::fmod(d0, 8.0);
    }

    St[((unsigned char)(signed char)d1 & 7) + 2] = S[i];
    if (rtIsNaN(d0) || rtIsInf(d0)) {
      d0 = 0.0;
    } else {
      d0 = std::fmod(d0, 8.0);
    }

    St[((unsigned char)(signed char)d0 & 7) + 3] = S[i + 2];
  }
}

//
// File trailer for MatrixS_transpose_fixpt.cpp
//
// [EOF]
//
