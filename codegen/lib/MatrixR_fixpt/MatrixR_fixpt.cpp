//
// Prerelease License - for engineering feedback and testing purposes
// only. Not for sale.
// File: MatrixR_fixpt.cpp
//
// MATLAB Coder version            : 4.1
// C/C++ source code generated on  : 28-Jun-2018 14:35:34
//

// Include Files
#include <cmath>
#include "rt_nonfinite.h"
#include "MatrixR_fixpt.h"

// Function Definitions

//
// Arguments    : const unsigned short V[4]
//                const short H[8]
//                const short St[8]
//                unsigned short Rmat[4]
// Return Type  : void
//
void MatrixR_fixpt(const unsigned short V[4], const short H[8], const short St[8],
                   unsigned short Rmat[4])
{
  int i0;
  int i1;
  double d0;
  double d1;
  int b_i0;
  int b_i1;
  int i2;
  int i3;
  int i4;
  int i5;
  int i6;
  int i7;
  int i8;
  int i9;
  int i10;
  int i11;
  double d2;
  int i12;

  // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
  //                                                                           % 
  //            Generated by MATLAB 9.5 and Fixed-Point Designer 6.2           % 
  //                                                                           % 
  // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
  Rmat[0] = 0U;
  Rmat[1] = 0U;
  Rmat[2] = 0U;
  Rmat[3] = 0U;
  for (i0 = 0; i0 < 2; i0++) {
    for (i1 = 0; i1 < 2; i1++) {
      d0 = std::floor((double)((unsigned long)i1 << 2UL));
      if (rtIsNaN(d0) || rtIsInf(d0)) {
        d1 = 0.0;
      } else {
        d1 = std::fmod(d0, 8.0);
      }

      b_i0 = H[i0] * St[(unsigned char)(signed char)d1 & 7];
      if ((b_i0 & 67108864) != 0) {
        b_i1 = b_i0 | -67108864;
      } else {
        b_i1 = b_i0 & 67108863;
      }

      b_i0 = b_i1 << 1;
      if ((b_i0 & 536870912) != 0) {
        b_i0 |= -536870912;
      } else {
        b_i0 &= 536870911;
      }

      if (rtIsNaN(d0) || rtIsInf(d0)) {
        d1 = 0.0;
      } else {
        d1 = std::fmod(d0, 8.0);
      }

      i2 = H[i0 + 2] * St[((unsigned char)(signed char)d1 & 7) + 1];
      if ((i2 & 67108864) != 0) {
        i3 = i2 | -67108864;
      } else {
        i3 = i2 & 67108863;
      }

      i2 = i3 << 1;
      if ((b_i0 & 536870912) != 0) {
        i4 = b_i0 | -536870912;
      } else {
        i4 = b_i0 & 536870911;
      }

      if ((i2 & 536870912) != 0) {
        i5 = i2 | -536870912;
      } else {
        i5 = i2 & 536870911;
      }

      b_i0 = (unsigned short)i4 + i5;
      if (rtIsNaN(d0) || rtIsInf(d0)) {
        d1 = 0.0;
      } else {
        d1 = std::fmod(d0, 8.0);
      }

      i2 = H[i0] * St[((unsigned char)(signed char)d1 & 7) + 2];
      if ((i2 & 67108864) != 0) {
        i6 = i2 | -67108864;
      } else {
        i6 = i2 & 67108863;
      }

      i2 = i6 << 1;
      if ((b_i0 & 536870912) != 0) {
        i7 = b_i0 | -536870912;
      } else {
        i7 = b_i0 & 536870911;
      }

      if ((i2 & 536870912) != 0) {
        i8 = i2 | -536870912;
      } else {
        i8 = i2 & 536870911;
      }

      b_i0 = (unsigned short)i7 + i8;
      if (rtIsNaN(d0) || rtIsInf(d0)) {
        d0 = 0.0;
      } else {
        d0 = std::fmod(d0, 8.0);
      }

      i2 = H[i0 + 2] * St[((unsigned char)(signed char)d0 & 7) + 3];
      if ((i2 & 67108864) != 0) {
        i9 = i2 | -67108864;
      } else {
        i9 = i2 & 67108863;
      }

      i2 = i9 << 1;
      if ((b_i0 & 536870912) != 0) {
        i10 = b_i0 | -536870912;
      } else {
        i10 = b_i0 & 536870911;
      }

      if ((i2 & 536870912) != 0) {
        i11 = i2 | -536870912;
      } else {
        i11 = i2 & 536870911;
      }

      b_i0 = (unsigned short)i10 + i11;
      d2 = std::floor((double)((unsigned long)i1 << 1UL));
      if (rtIsNaN(d2) || rtIsInf(d2)) {
        d0 = 0.0;
        d2 = 0.0;
      } else {
        d0 = std::fmod(d2, 4.0);
        d2 = std::fmod(d2, 4.0);
      }

      if ((b_i0 & 536870912) != 0) {
        i12 = b_i0 | -536870912;
      } else {
        i12 = b_i0 & 536870911;
      }

      Rmat[(int)((unsigned int)(1 + i0) + ((unsigned char)(signed char)d0 & 3))
        - 1] = (unsigned short)((V[(int)((unsigned int)(1 + i0) + ((unsigned
        char)(signed char)d2 & 3)) - 1] + ((unsigned int)(unsigned short)i12 <<
        4)) >> 4);
    }
  }
}

//
// File trailer for MatrixR_fixpt.cpp
//
// [EOF]
//
